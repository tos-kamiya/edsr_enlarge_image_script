#!/usr/bin/env python3

import os
import sys

# import tensorflow as tf  # Use GPU
import cv2
from cv2 import dnn_superres

from docopt import docopt


_script_dir = os.path.dirname(os.path.realpath(__file__))

# https://docs.opencv.org/2.4/modules/highgui/doc/reading_and_writing_images_and_video.html?highlight=imread#imread
IMAGE_EXTENSIONS = [
    ".bmp", ".dib",
    ".jpeg", ".jpg", ".jpe",
    ".png",
    ".pbm", ".pgm", ".ppm",
    ".sr", ".ras",
]


def gen_sr(scale):
    sr = dnn_superres.DnnSuperResImpl_create()

    path = os.path.join(_script_dir, "EDSR_x%d.pb" % scale)
    sr.readModel(path)
    sr.setModel("edsr", scale)
    
    # Use GPU
    # if tf.test.is_gpu_available():
    #     sr.setPreferableBackend(cv2.dnn.DNN_BACKEND_CUDA)
    #     sr.setPreferableTarget(cv2.dnn.DNN_TARGET_CUDA)

    return sr


def sr_apply(sr, input_file, output_file):
    image = cv2.imread(input_file)
    result = sr.upsample(image)
    cv2.imwrite(output_file, result)


def mod_path(p, suffix):
    fp, e = os.path.splitext(p)
    return fp + suffix + e


__doc__ = """Enlarge images.

Usage:
  {argv0} <scale> <input> [-o OUTPUT]
  {argv0} <scale> -d <input> [-o OUTPUT]

Options:
  -o OUTPUT     Output file.
  -d            Read images from the <input> dir and write the results into OUTPUT dir, which will be generated if needed.
""".format(argv0=os.path.basename(sys.argv[0]))


def main():
    args = docopt(__doc__)

    scale = args['<scale>']
    assert scale in ('2', '3', '4')
    scale = int(scale)
    input_file = args['<input>']
    output_file = args['-o']
    option_dir = args['-d']

    sr = gen_sr(scale)

    if option_dir:
        assert os.path.isdir(input_file)
        input_dir = input_file
        if not output_file:
            output_dir = mod_path(input_dir, "-x%d" % scale)
        else:
            output_dir = output_file
        if not os.path.exists(output_dir):
            os.mkdir(output_dir)

        files = os.listdir(input_dir)
        files = [f for f in files if os.path.splitext(f)[1] in IMAGE_EXTENSIONS]
        files.sort()
        for f in files:
            input_file = os.path.join(input_dir, f)
            output_file = os.path.join(output_dir, f)
            sr_apply(sr, input_file, output_file)
    else:
        assert os.path.isfile(input_file)
        if not output_file:
            output_file = mod_path(input_file, "-x%d" % scale)
        sr_apply(sr, input_file, output_file)


if __name__ == '__main__':
    main()
